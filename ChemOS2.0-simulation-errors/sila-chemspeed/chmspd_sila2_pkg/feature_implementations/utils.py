
# Generated by sila2.code_generator; sila2.__version__: 0.10.1
from __future__ import annotations


import os
import shutil
import subprocess
from chemspeed_operator_process.Utils import timestamp_datetime
import time
from typing import TYPE_CHECKING
import socket
import sys
import errno
from pathlib import Path
from typing import TYPE_CHECKING

from sila2.server import MetadataDict, ObservableCommandInstanceWithIntermediateResponses

from ..generated.chemspeedoperator import (
    Addbatch_IntermediateResponses,
    Addbatch_Responses,
    ChangeProcedure_Responses,
    ChemSpeedOperatorBase,
    Filter_IntermediateResponses,
    Filter_Responses,
    GetInventory_Responses,
    GetRackpositions_Responses,
    Inject_IntermediateResponses,
    Inject_Responses,
)

import json

if TYPE_CHECKING:
    from ..server import Server

OUTPUT: Path = "chmspd_output"
COMPLETEDDIR = os.path.join(os.path.join(OUTPUT, "Synthesis"), "Completed_Batches")
HEADER_LENGTH = 10

OUTPUT: Path = Path("chmspd_output")
STORAGE: Path =Path('chmspd_storage')
MODULES: Path  = OUTPUT/"ChemSpeed_Modules"
INVENTORY: Path = OUTPUT/"Storage_Inventory"/"Inventory.json"
BATCHFOLDER: Path = OUTPUT/"Synthesis/Batches_to_Make"
PROCEDUREDIR = OUTPUT/"Synthesis/Procedure"


def validate_inject_position(position):
    location = None
    for module in ["RACKL", "RACKR", "SPE"]:
        if position.startswith(module):
            location = module

    if location is None: return False

    ## LOAD status of the location rack on the chemspeed
    with open(MODULES/f"{location}.json", "r") as f:
        rackState = json.load(f)
    
    try:
        if location == "SPE":
            if (position.replace("SPE_D:", "SPE:")) in rackState:
                return True
        elif position in rackState:
            return True
        else:
            return False
    except:
        return False


def validate_filter_position(position):
    location = None
    for module in ["RACKL", "RACKR"]:
        if position.startswith(module):
            location = module
    if location is None: return False
    ## LOAD status of the location rack on the chemspeed
    with open(MODULES/f"{location}.json", "r") as f:
        rackState = json.load(f) 
    try:
        if position in rackState: 
            return True 
        else:
            return False
    except:
        return False

def isbusy():
    statusfile = os.path.join(OUTPUT, "status.txt")
    with open(statusfile, "r") as f:
        status = f.read()
    if status == "active":
        return True
    elif status == "inactive":
        return False
    else:
        raise ValueError

def run_synthesis_client(client_socket, instance, batchtoken, batchfile):
    while True:
        try:
            while True:
                username_header = client_socket.recv(HEADER_LENGTH)
                if not len(username_header):
                    print('Connection closed by the server')
                    sys.exit()
                username_length = int(username_header.decode('utf-8').strip())
                username = client_socket.recv(username_length).decode('utf-8')
                message_header = client_socket.recv(HEADER_LENGTH)
                message_length = int(message_header.decode('utf-8').strip())
                message = client_socket.recv(message_length).decode('utf-8')

                # Print message
                print(f'{username} > {message}')

                
                instance.send_intermediate_response(Addbatch_IntermediateResponses(message, "operations"))
                if message == f'Synthesis: Synthesis of batch {batchtoken} has been completed':
                    with open(os.path.join(COMPLETEDDIR, f"{batchtoken}_Operations.json"), 'r') as file:
                        data = file.read()
                    instance.send_intermediate_response(Addbatch_IntermediateResponses('silasocket_operations', f"{data}"))

                    time.sleep(4)

                    return "synthesis complete"

        except IOError as e:
            if e.errno != errno.EAGAIN and e.errno != errno.EWOULDBLOCK:
                print('Reading error: {}'.format(str(e)))
                sys.exit()
            continue

        except Exception as e:
            print('Reading error: '.format(str(e)))
            sys.exit()

def run_filter_client(client_socket, instance, datadict):
    rackposition= None
    while True:
        try:
            while True:
                username_header = client_socket.recv(HEADER_LENGTH)
                if not len(username_header):
                    print('Connection closed by the server')
                    sys.exit()
                username_length = int(username_header.decode('utf-8').strip())
                username = client_socket.recv(username_length).decode('utf-8')
                message_header = client_socket.recv(HEADER_LENGTH)
                message_length = int(message_header.decode('utf-8').strip())
                message = client_socket.recv(message_length).decode('utf-8')

                # Print message
                print(f'{username} > {message}')
                if message == f'Characterization: Filtering done for {datadict["Identifier"]}':
                    instance.send_intermediate_response(Filter_IntermediateResponses(message, "operations"))
                    if rackposition is not None:
                        return f"{rackposition}" 
                    else:
                        return "Product filtered. please verify SPE position before injection"
                elif message.startswith(f'Characterization: Filtering compound for {datadict["Identifier"]}'):
                    instance.send_intermediate_response(Filter_IntermediateResponses(message, "operations"))
                    positionstring = message[-5:]
                    if positionstring[-1:].isdigit():
                        rackposition = f"SPE_C:{positionstring[-1:]}"
                    else:
                        rackposition = f"SPE_C:{positionstring[-1]}"

                else:
                    instance.send_intermediate_response(Filter_IntermediateResponses(message, "operations"))

        except IOError as e:
            if e.errno != errno.EAGAIN and e.errno != errno.EWOULDBLOCK:
                print('Reading error: {}'.format(str(e)))
                sys.exit()
            continue
        except Exception as e:
            print('Reading error: '.format(str(e)))
            sys.exit()
def run_inject_client(client_socket, instance, datadict):
    while True:
        try:
            while True:
                username_header = client_socket.recv(HEADER_LENGTH)
                if not len(username_header):
                    print('Connection closed by the server')
                    sys.exit()
                username_length = int(username_header.decode('utf-8').strip())
                username = client_socket.recv(username_length).decode('utf-8')
                message_header = client_socket.recv(HEADER_LENGTH)
                message_length = int(message_header.decode('utf-8').strip())
                message = client_socket.recv(message_length).decode('utf-8')
                instance.send_intermediate_response(Filter_IntermediateResponses(message, "operations"))
                if message == f'Characterization: Injection done for {datadict["Identifier"]}':
                    instance.send_intermediate_response(Filter_IntermediateResponses(message, "operations"))
                    return "Product Filtered"

        except IOError as e:
            if e.errno != errno.EAGAIN and e.errno != errno.EWOULDBLOCK:
                print('Reading error: {}'.format(str(e)))
                sys.exit()
            continue
        except Exception as e:
            print('Reading error: '.format(str(e)))
            sys.exit()
