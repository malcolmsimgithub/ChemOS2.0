# Generated by sila2.code_generator; sila2.__version__: 0.10.1
from __future__ import annotations

from typing import TYPE_CHECKING

from sila2.server import MetadataDict, ObservableCommandInstanceWithIntermediateResponses

from ..generated.chemspeedoperator import (
    Addbatch_IntermediateResponses,
    Addbatch_Responses,
    ChangeProcedure_Responses,
    ChemSpeedOperatorBase,
    Filter_IntermediateResponses,
    Filter_Responses,
    GetInventory_Responses,
    GetRackpositions_Responses,
    Inject_IntermediateResponses,
    Inject_Responses,
)

if TYPE_CHECKING:
    from ..server import Server

import os
import shutil
from chemspeed_operator_process.Utils import timestamp_datetime
from typing import TYPE_CHECKING
import socket
from pathlib import Path
import pandas as pd
import json
import glob
import time

from .utils import run_synthesis_client, run_inject_client, run_filter_client, validate_inject_position, validate_filter_position

OUTPUT: Path = Path("chmspd_output")
STORAGE: Path =Path('chmspd_storage')
MODULES: Path  = OUTPUT/"ChemSpeed_Modules"
INVENTORY: Path = OUTPUT/"Storage_Inventory"/"Inventory.json"
BATCHFOLDER: Path = OUTPUT/"Synthesis/Batches_to_Make"
PROCEDUREDIR = OUTPUT/"Synthesis/Procedure"
COMPLETEDDIR = OUTPUT/"Synthesis/Completed_Batches"
CHARFILE = OUTPUT/"Characterization/Positions_for_Characterization.csv"
HEADER_LENGTH = 10
SOCKET_IP = "127.0.0.1"
SOCKET_PORT = 65002


class ChemSpeedOperatorImpl(ChemSpeedOperatorBase):
    def __init__(self, parent_server: Server) -> None:
        super().__init__(parent_server=parent_server)

    def ChangeProcedure(self, SynthesisProcedure: str, *, metadata: MetadataDict) -> ChangeProcedure_Responses:
            shutil.copyfile(STORAGE/SynthesisProcedure, PROCEDUREDIR/SynthesisProcedure)
            return ChangeProcedure_Responses("Procedure succesfully changed")


    def GetRackpositions(self, *, metadata: MetadataDict) -> GetRackpositions_Responses:
        time.sleep(3)

        filelist = []

        for module in ["RACKL", "RACKR", "SPE"]:

            with open(MODULES/f"{module}.json", "r") as f:
                moduledict = json.load(f)
                filelist.append(moduledict)
        
        return GetRackpositions_Responses("data delivered", 
            str(filelist[0]), 
            str(filelist[1]), 
            str(filelist[2])
        )

    def GetInventory(self, *, metadata: MetadataDict) -> GetInventory_Responses:
        with open(INVENTORY, "r") as f:
            inventorydict = json.load(f)
        
        return(GetInventory_Responses(str(inventorydict)))

    def Addbatch(
        self,
        BatchName: str,
        Batchfile: str,
        *,
        metadata: MetadataDict,
        instance: ObservableCommandInstanceWithIntermediateResponses[Addbatch_IntermediateResponses],
    ) -> Addbatch_Responses:
        instance.begin_execution()  # set execution status from `waiting` to `running`

        evaldict = eval(Batchfile) 

        datetime = timestamp_datetime()
        batchfile = f"{BatchName}_{datetime}.json"

        batchtoken = batchfile.strip(".json")
        with open( os.path.join(BATCHFOLDER,batchfile), 'w') as f:
            json.dump(evaldict, f)
        instance.send_intermediate_response(Addbatch_IntermediateResponses("starting synthesis", "operation string"))

        my_username = "sila2_synthesis"

        # Create a socket
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect((SOCKET_IP, SOCKET_PORT))
        client_socket.setblocking(False)
        username = my_username.encode('utf-8')
        username_header = f"{len(username):<{HEADER_LENGTH}}".encode('utf-8')
        client_socket.send(username_header + username)
        return Addbatch_Responses(run_synthesis_client(client_socket, instance, batchtoken, batchfile))

    def Filter(
        self,
        RackPosition: str,
        *,
        metadata: MetadataDict,
        instance: ObservableCommandInstanceWithIntermediateResponses[Filter_IntermediateResponses],
    ) -> Filter_Responses:
        instance.begin_execution()  # set execution status from `waiting` to `running`
        jobname = f"Filtration_{timestamp_datetime()}"

        if validate_filter_position(RackPosition) is False:
            return Filter_Responses("invalid position!!")
        datadict = {}
        datadict['Identifier'] = jobname
        datadict['Operation'] = 'filter_collect'
        datadict['Position'] = RackPosition
  
        my_username = "sila2_filter"

        # Create a socket
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect((SOCKET_IP, SOCKET_PORT))
        client_socket.setblocking(False)
        username = my_username.encode('utf-8')
        username_header = f"{len(username):<{HEADER_LENGTH}}".encode('utf-8')
        client_socket.send(username_header + username)

        with open(OUTPUT/f"Characterization/Characterizations_to_do/{jobname}.json", "w") as f:
            json.dump(datadict, f)

        return Filter_Responses(run_filter_client(client_socket, instance, datadict))

    def Inject(
        self,
        RackPosition: str,
        *,
        metadata: MetadataDict,
        instance: ObservableCommandInstanceWithIntermediateResponses[Inject_IntermediateResponses],
    ) -> Inject_Responses:
        instance.begin_execution()  # set execution status from `waiting` to `running`

        if validate_inject_position(RackPosition) is False:
            return Inject_Responses("invalid position!")

        jobname = f"Injection_{timestamp_datetime()}"

        datadict = {}
        datadict['Identifier'] = jobname
        datadict['Operation'] = 'inject_to_hplc'
        datadict['Position'] = RackPosition

        my_username = "sila2_Inject"

        # Create a socket
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect((SOCKET_IP, SOCKET_PORT))
        client_socket.setblocking(False)
        username = my_username.encode('utf-8')
        username_header = f"{len(username):<{HEADER_LENGTH}}".encode('utf-8')
        client_socket.send(username_header + username)


        with open(OUTPUT/f"Characterization/Characterizations_to_do/{jobname}.json", "w") as f:
            json.dump(datadict, f)

        return Filter_Responses(run_inject_client(client_socket, instance, datadict))
